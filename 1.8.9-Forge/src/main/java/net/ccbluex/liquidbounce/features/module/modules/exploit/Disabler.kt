/*
 * LiquidBounce+ Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/WYSI-Foundation/LiquidBouncePlus/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.features.module.modules.movement.Speed
import net.ccbluex.liquidbounce.features.module.modules.movement.LongJump
import net.ccbluex.liquidbounce.features.module.modules.exploit.helper.PacketThread
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.Notification
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.MovementUtils
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.misc.RandomUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.*
import net.minecraft.entity.player.PlayerCapabilities
import net.minecraft.network.handshake.client.C00Handshake
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.server.*
import io.netty.buffer.Unpooled
import net.minecraft.network.Packet
import net.minecraft.network.PacketBuffer
import net.minecraft.util.BlockPos
import net.minecraft.util.EnumFacing
import net.minecraft.world.WorldSettings.GameType

import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import java.io.IOException
import java.util.LinkedList

import kotlin.math.sqrt
import kotlin.math.round

@ModuleInfo(name = "Disabler", description = "Disable some anticheats' checks.", category = ModuleCategory.EXPLOIT)
class Disabler : Module() {

	private val modeValue = ListValue("Mode", 
		arrayOf(
			"Basic", // cancel c0f and c00
			"FakeLag", // use a packet bus
			"FakeLag2", // use threads to wait and then send packet async
			"SpartanCombat", // old spartan combat disabler
			"OldMatrix", // work with old matrix, around 5.2.x
			"OldGhostly", // self-explanation
			"Kauri", // kauri
			"Riding", // spoof c0c packet with real player data
			"Spectate", // spoof c18 with player uid
			"OldVerus", // Dort
			"OldHypixel", // Someone named LX sent me this mode in Discord. Very appreciate his support. (It's actually someone else code that I won't say here)
			"Verus" // my own verus disabler version
		), "Basic")

	private val minRand: IntegerValue = object : IntegerValue("FakeLag-MinDelay", 0, 0, 20000) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val v = maxRand.get()
            if (v < newValue) set(v)
        }
    }
    private val maxRand: IntegerValue = object : IntegerValue("FakeLag-MaxDelay", 0, 0, 20000) {
        override fun onChanged(oldValue: Int, newValue: Int) {
            val v = minRand.get()
            if (v > newValue) set(v)
        }
    }

	private val fakelagStrafe = BoolValue("FakeLag-StrafeDisabler", true)

	// Verus
	private val verusDelayMode = ListValue("Verus-DelayMode", arrayOf("PlayerTick", "System", "Dynamic"), "System")
	private val verusTickDelay = IntegerValue("Verus-TickDelay", 120, 0, 240)
	private val verusSystemDelay = IntegerValue("Verus-SystemDelay", 310, 0, 10000)
	private val verusTPTickDelay = IntegerValue("Verus-TeleportTickDelay", 80, 0, 240)
	private val verusDupe = IntegerValue("Verus-TransactionDupe", 6, 0, 100)
	private val verusKeepAliveDupe = IntegerValue("Verus-KeepAliveDupe", 6, 0, 100)
	private val verusDynamicDupe = BoolValue("Verus-DynamicDupe", false)
	private val verusMaxDynDupe = IntegerValue("Verus-MaxDynamicDupeAmount", 10, 1, 1000)
	private val verusActionDelay = IntegerValue("Verus-ServerJoinDelay", 0, 0, 240)
	private val verusc0c = BoolValue("Verus-RidingSpoof", false)
	private val verusAntiBan = BoolValue("Verus-AntiBan", false)
	private val verusCombat = BoolValue("Verus-CombatTest", false)
	private val verusSilent = BoolValue("Verus-SilentSetback", false)
	private val verusNofall = BoolValue("Verus-Nofall", false)
	private val verusBusMinTransactionSize = IntegerValue("Verus-Bus-MinTransactionSize", 0, 0, 240)
	private val verusBusMinKeepAliveSize = IntegerValue("Verus-Combat-MinKeepAliveSize", 0, 0, 240)

	private val debugValue = BoolValue("Debug", false)

	private val keepAlives = arrayListOf<C00PacketKeepAlive>()
	private val transactions = arrayListOf<C0FPacketConfirmTransaction>()
	private val packetQueue = LinkedList<C0FPacketConfirmTransaction>()
	private val anotherQueue = LinkedList<C00PacketKeepAlive>()

	private val packetBus = hashMapOf<Long, Packet<INetHandlerPlayServer>>()
	
	private val msTimer = MSTimer()

	private var dState = 0
	private var sendYModify = false

	private var dynamicDelay = 0
	private var lastReceive: Long = 0L

	fun debug(s: String) {
		if (debugValue.get())
			ClientUtils.displayChatMessage("§7[§3§lDisabler§7]§f $s")
	}

	override fun onEnable() {
		keepAlives.clear()
		transactions.clear()
		packetQueue.clear()
		anotherQueue.clear()
		packetBus.clear()

		msTimer.reset()
		dState = 0
		dynamicDelay = verusSystemDelay.get()
		sendYModify = false
	}

	override fun onDisable() {
		keepAlives.forEach {
			PacketUtils.sendPacketNoEvent(it)
		}
		transactions.forEach {
			PacketUtils.sendPacketNoEvent(it)
		}

		keepAlives.clear()
		transactions.clear()
		packetQueue.clear()
		anotherQueue.clear()
		packetBus.clear()

		msTimer.reset()

		mc.thePlayer.motionY = 0.0
		MovementUtils.strafe(0F)
		mc.timer.timerSpeed = 1F
	}

	@EventTarget
	fun onPacket(event: PacketEvent) {
		val packet = event.packet
	
		when (modeValue.get().toLowerCase()) {
			"oldmatrix" -> if (packet is C03PacketPlayer && mc.thePlayer.ticksExisted % 15 == 0) {
				try {
					val b = ByteArrayOutputStream()
	                val _out = DataOutputStream(b)
	                _out.writeUTF(mc.thePlayer.gameProfile.getName())
	                val buf = PacketBuffer(Unpooled.buffer())
	                buf.writeBytes(b.toByteArray())
	                mc.netHandler.addToSendQueue(C17PacketCustomPayload("matrix:geyser", buf))
				} catch (e: IOException) {

				}
			}
			"kauri" -> if (packet is C0FPacketConfirmTransaction) event.cancelEvent()
			"riding" -> if (packet is C03PacketPlayer) mc.netHandler.addToSendQueue(C0CPacketInput(mc.thePlayer.moveStrafing, mc.thePlayer.moveForward, mc.thePlayer.movementInput.jump, mc.thePlayer.movementInput.sneak))
			"basic" -> if (packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive) event.cancelEvent()
			"oldghostly" -> {
				if (packet is C03PacketPlayer) mc.netHandler.addToSendQueue(C0CPacketInput())
				if (packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive) event.cancelEvent()
			}
			"spartancombat" -> {
        		if (packet is C00PacketKeepAlive && (keepAlives.size <= 0 || packet != keepAlives[keepAlives.size - 1])) {
            		keepAlives.add(packet)
            		event.cancelEvent()
        		}
        		if (packet is C0FPacketConfirmTransaction && (transactions.size <= 0 || packet != transactions[transactions.size - 1])) {
            		transactions.add(packet)
            		event.cancelEvent()
        		}
			}
			"spectate" -> if (packet is C03PacketPlayer) mc.netHandler.addToSendQueue(C18PacketSpectate(mc.thePlayer.uniqueID))
			"oldverus" -> {
				/*if (mc.thePlayer != null && mc.thePlayer.ticksExisted == 0)
					packetQueue.clear()

					not really necessary since the clear implementation was added below
				*/

				if (packet is C03PacketPlayer) {
					val yPos = round(mc.thePlayer.posY / 0.015625) * 0.015625
					mc.thePlayer.setPosition(mc.thePlayer.posX, yPos, mc.thePlayer.posZ)

					if (mc.thePlayer.ticksExisted % 45 == 0) {
						PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
            			PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY - 11.725, mc.thePlayer.posZ, false))
            			PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, true))
					}
				}

				if (packet is S08PacketPlayerPosLook) {
					if (mc.thePlayer == null || mc.thePlayer.ticksExisted <= 0) return

					var x = packet.getX() - mc.thePlayer.posX
      				var y = packet.getY() - mc.thePlayer.posY
      				var z = packet.getZ() - mc.thePlayer.posZ
      				var diff = sqrt(x * x + y * y + z * z)
      				if (diff <= 8) {
        				event.cancelEvent()
        				PacketUtils.sendPacketNoEvent(C03PacketPlayer.C06PacketPlayerPosLook(packet.getX(), packet.getY(), packet.getZ(), packet.getYaw(), packet.getPitch(), true))
      				}
				}

				if (packet is C0FPacketConfirmTransaction) {
					repeat (4) {
						packetQueue.add(packet)
					}
					event.cancelEvent()
				}
			}
			"oldhypixel" -> {
				if (packet is C0FPacketConfirmTransaction)
				{
					repeat (4) {
						transactions.add(packet)
					}
					event.cancelEvent()
					debug("duped transaction 4x.")
				}

				if (mc.thePlayer.ticksExisted > 100) {
					if (transactions.size > 30) {
						transactions.forEach { 
							try {
								PacketUtils.sendPacketNoEvent(it) 
							} catch (e: Exception) {
								// ignore, fix errors spamming the log.
							}
						}
						transactions.clear()
						debug("Flushed transactions queue.")
						if (dState == 0) dState++
					}
				} else if (mc.thePlayer == null || mc.thePlayer.ticksExisted < 100) {
					transactions.clear()
					dState = 0
				}

				if (dState == 1) {
					LiquidBounce.hud.addNotification(Notification("You may be able to use some features now.", Notification.Type.SUCCESS, 5000L))
					dState++
				}
			}
			"fakelag" -> {
				if (packet is C0FPacketConfirmTransaction) {
					debug("transferred a c0f to packet bus")
					packetBus.put((System.currentTimeMillis() + RandomUtils.nextInt(minRand.get(), maxRand.get())).toLong(), packet)
					event.cancelEvent()
				}
				
				if (packet is C00PacketKeepAlive) {
					debug("transferred a c00 to packet bus")
					packetBus.put((System.currentTimeMillis() + RandomUtils.nextInt(minRand.get(), maxRand.get())).toLong(), packet)
					event.cancelEvent()
				}
			}
			"fakelag2" -> {
				if (packet is C0FPacketConfirmTransaction) {
					debug("start c0f packet thread")
					PacketThread(packet, RandomUtils.nextInt(minRand.get(), maxRand.get()).toLong(), true).start()
					event.cancelEvent()
				}
				
				if (packet is C00PacketKeepAlive) {
					debug("start c00 packet thread")
					PacketThread(packet, RandomUtils.nextInt(minRand.get(), maxRand.get()).toLong(), true).start()
					event.cancelEvent()
				}
			}
			"verus" -> {
				if (mc.thePlayer == null || mc.theWorld == null || mc.thePlayer.ticksExisted <= verusActionDelay.get()) return
				if (packet is C0FPacketConfirmTransaction) {
					if (lastReceive != 0L)
					{
						dynamicDelay = (System.currentTimeMillis() - lastReceive).toInt()
						//if (verusDelayMode.get().equals("dynamic", true)) debug("dynamic: ${dynamicDelay}ms")
					}
					lastReceive = System.currentTimeMillis()

					debug("c0f, uid ${packet.uid}, window id ${packet.windowId}")

					if (verusAntiBan.get()) {
						packet.windowId = 65536
						packet.uid = 32767
					}

					val dupeAmount = if (verusDynamicDupe.get()) (dynamicDelay.toDouble() / 50.0).coerceAtMost(verusMaxDynDupe.get().toDouble()).toInt() else verusDupe.get() // im not going to rape the packet bus
					repeat (dupeAmount) {
						packetQueue.add(packet)
					}

					debug("dupe transaction $dupeAmount times.")

					event.cancelEvent()
				}
				if (packet is C00PacketKeepAlive) {
					if (verusCombat.get()) {
						packet.key -= RandomUtils.nextInt(1000, 2147483647)
						val dupeAmount = if (verusDynamicDupe.get()) (dynamicDelay.toDouble() / 50.0).coerceAtMost(verusMaxDynDupe.get().toDouble()).toInt() else verusKeepAliveDupe.get() // im not going to rape the packet bus
						repeat (dupeAmount) {
							anotherQueue.add(packet)
						}
						event.cancelEvent()
					}
				}
				if (packet is C03PacketPlayer) {
					if (verusNofall.get() && mc.thePlayer.fallDistance > 2.5) {
						packet.y -= mc.thePlayer.fallDistance.toDouble()
						packet.onGround = true
						mc.thePlayer.fallDistance = 0
					}

					if (mc.thePlayer.ticksExisted % verusTickDelay.get() == 0) {
						PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(packet.x, packet.y, packet.z, packet.onGround))
						PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(packet.x, packet.y - 11.625, packet.z, packet.onGround)) 
						PacketUtils.sendPacketNoEvent(C03PacketPlayer.C04PacketPlayerPosition(packet.x, packet.y, packet.z, packet.onGround))

						debug("flag")
					}

					if (verusc0c.get()) { // ????? wtf am i doing
						PacketUtils.sendPacketNoEvent(C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.RIDING_JUMP))
						PacketUtils.sendPacketNoEvent(C0CPacketInput(mc.thePlayer.moveStrafing, mc.thePlayer.moveForward, true, mc.thePlayer.movementInput.sneak))
					}
				}

				if (packet is S08PacketPlayerPosLook) {
					if (!verusSilent.get())
						return
					// in some servers, if you cancel s08 too early then you wont get into the ingame gui, resulting in stuck.
					var x = packet.getX() - mc.thePlayer.posX
      				var y = packet.getY() - mc.thePlayer.posY
      				var z = packet.getZ() - mc.thePlayer.posZ
      				var diff = sqrt(x * x + y * y + z * z)
      				if (diff < 8) { //may cause the player to desync from server.
        				event.cancelEvent()
        				PacketUtils.sendPacketNoEvent(C03PacketPlayer.C06PacketPlayerPosLook(packet.getX(), packet.getY(), packet.getZ(), packet.getYaw(), packet.getPitch(), false)) // idk why, just copy vanilla packet handling
						debug("silent s08 accept")
      				}
				}
			}
		}
	}

	@EventTarget
	fun onMotion(event: MotionEvent) {
		val speed = LiquidBounce.moduleManager.getModule(Speed::class.java)!!
		val lj = LiquidBounce.moduleManager.getModule(LongJump::class.java)!!
		if ((modeValue.get().equals("oldhypixel", true) || ((modeValue.get().equals("fakelag", true) || modeValue.get().equals("fakelag2", true)) && fakelagStrafe.get())) && event.onGround && (speed.state || lj.state)) {
			if (!sendYModify) {
				event.y += .004 * Math.random()
				debug("Sent Y offset.")
				sendYModify = true
			}
		} else
			sendYModify = false
	}

	@EventTarget
	fun onWorld(event: WorldEvent) {
		transactions.clear()
		keepAlives.clear()
		packetQueue.clear()
		anotherQueue.clear()
		packetBus.clear()

		msTimer.reset()
		dState = 0
	}

	@EventTarget
	fun onUpdate(event: UpdateEvent) {
		when (modeValue.get().toLowerCase()) {
			"spartancombat" -> {
				if (msTimer.hasTimePassed(3000L) && keepAlives.size > 0 && transactions.size > 0) {
					PacketUtils.sendPacketNoEvent(keepAlives[keepAlives.size - 1])
					PacketUtils.sendPacketNoEvent(transactions[transactions.size - 1])
					keepAlives.clear()
					transactions.clear()
					msTimer.reset()
				}
			}
			"oldverus" -> {
				if (mc.thePlayer.ticksExisted % 180 == 0) {
      				while (packetQueue.size > 22) {
        				PacketUtils.sendPacketNoEvent(packetQueue.poll())
      				}
    			}
			}
			"verus" -> {
				if (packetQueue.isEmpty() || (verusCombat.get() && anotherQueue.isEmpty()) || packetQueue.size < verusBusMinTransactionSize.get() || (verusCombat.get() && anotherQueue.size < verusBusMinKeepAliveSize.get()) || mc.thePlayer == null || mc.theWorld == null) 
				{
					msTimer.reset() // make sure to reset it
					return
				}

				if (verusDelayMode.get().equals("playertick", true)) {
					if (mc.thePlayer.ticksExisted % verusTickDelay.get() == 0) {
						try {
							if (verusCombat.get()) {
								val kaPacket: C00PacketKeepAlive = anotherQueue.poll()
								PacketUtils.sendPacketNoEvent(kaPacket)
								debug("poll keepalive packet at tick ${mc.thePlayer.ticksExisted}. key ${kaPacket.key}.")
							}
							val packet: C0FPacketConfirmTransaction = packetQueue.poll()
							PacketUtils.sendPacketNoEvent(packet)
							debug("poll transaction packet at tick ${mc.thePlayer.ticksExisted}. uid ${packet.uid}, windowId ${packet.windowId}.")
						} catch (e: Exception) {
							e.printStackTrace()
						}
					}
				} else {
					val timerDelay = if (verusDelayMode.get().equals("dynamic", true)) dynamicDelay else verusSystemDelay.get()
					if (msTimer.hasTimePassed(timerDelay.toLong())) {
						try {
							if (verusCombat.get()) {
								val kaPacket: C00PacketKeepAlive = anotherQueue.poll()
								PacketUtils.sendPacketNoEvent(kaPacket)
								debug("poll keepalive packet, rate: ${timerDelay}ms. key ${kaPacket.key}.")
							}
							val packet: C0FPacketConfirmTransaction = packetQueue.poll()
							PacketUtils.sendPacketNoEvent(packet)
							debug("poll transaction packet, rate: ${timerDelay}ms. uid ${packet.uid}, windowId ${packet.windowId}.")
						} catch (e: Exception) {
							e.printStackTrace()
						}
						msTimer.reset()
					}
				}
			}
			"fakelag" -> {
				try {
					val iter = packetBus.keys.iterator()
					while (iter.hasNext()) {
						val time = iter.next()
						val packet = packetBus[time]
						val packetType = if (packet is C0FPacketConfirmTransaction) "c0f" else "c00"
						if (System.currentTimeMillis() >= time) {
							PacketUtils.sendPacketNoEvent(packet)
							debug("$packetType push! ($time)")
							iter.remove()
						}
					}
				} catch (e: Exception) {
					// ignore
				}
			}
		}
	}
}